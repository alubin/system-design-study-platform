export interface Flashcard {
  id: string
  deck: string
  front: string
  back: string
  category?: string
}

export const decks = [
  { id: 'core-concepts', name: 'Core Concepts', description: 'Fundamental system design concepts' },
  { id: 'design-patterns', name: 'Design Patterns', description: 'Common architectural patterns' },
  { id: 'quick-definitions', name: 'Quick Definitions', description: 'Essential terminology' },
  { id: 'trade-offs', name: 'Trade-off Questions', description: 'When to choose X over Y' },
]

export const flashcards: Flashcard[] = [
  // CORE CONCEPTS DECK
  {
    id: 'cc-1',
    deck: 'core-concepts',
    front: 'What is Change Data Capture (CDC)?',
    back: 'A set of software design patterns used to determine and track changes in data so that action can be taken using the changed data. It monitors and captures changes (inserts, updates, deletes) in a database and makes them available to downstream systems.',
    category: 'data-pipeline',
  },
  {
    id: 'cc-2',
    deck: 'core-concepts',
    front: 'What are the three main CDC methods?',
    back: '1. Timestamp-based: Uses last_modified column. 2. Diff-based: Compares row hashes. 3. Log-based: Reads database transaction logs (binlog, WAL)',
    category: 'data-pipeline',
  },
  {
    id: 'cc-3',
    deck: 'core-concepts',
    front: 'What is idempotency?',
    back: 'An operation that produces the same result no matter how many times it is executed. Critical for distributed systems where retries are inevitable. f(x) = f(f(x))',
    category: 'data-pipeline',
  },
  {
    id: 'cc-4',
    deck: 'core-concepts',
    front: 'What is exactly-once delivery?',
    back: 'A guarantee that each message is delivered and processed exactly one time. The hardest delivery guarantee to achieve, requiring idempotent consumers, transactional outbox pattern, or distributed transactions.',
    category: 'data-pipeline',
  },
  {
    id: 'cc-5',
    deck: 'core-concepts',
    front: 'Difference between at-least-once and at-most-once delivery?',
    back: 'At-least-once: May deliver duplicates (acknowledge after processing). At-most-once: May lose messages (acknowledge before processing). Most systems use at-least-once + idempotent processing to achieve exactly-once semantics.',
    category: 'distributed',
  },
  {
    id: 'cc-6',
    deck: 'core-concepts',
    front: 'What is the CAP theorem?',
    back: 'Consistency, Availability, Partition tolerance. In the presence of network partitions, you must choose between consistency and availability. Most distributed systems choose AP or CP based on requirements.',
    category: 'distributed',
  },
  {
    id: 'cc-7',
    deck: 'core-concepts',
    front: 'What is eventual consistency?',
    back: 'A consistency model where the system guarantees that, if no new updates are made, all replicas will eventually converge to the same value. Allows for temporary inconsistency in exchange for availability and performance.',
    category: 'distributed',
  },
  {
    id: 'cc-8',
    deck: 'core-concepts',
    front: 'What is a dead letter queue (DLQ)?',
    back: 'A queue for messages that failed processing after maximum retry attempts. Allows system to continue processing other messages while problematic ones are investigated. Essential for robust async job processing.',
    category: 'distributed',
  },
  {
    id: 'cc-9',
    deck: 'core-concepts',
    front: 'Explain the token bucket algorithm',
    back: 'Rate limiting algorithm that allows bursts. Bucket holds tokens, refills at steady rate. Each request consumes a token. Allows momentary bursts up to bucket capacity while enforcing average rate limit.',
    category: 'distributed',
  },
  {
    id: 'cc-10',
    deck: 'core-concepts',
    front: 'What is backpressure?',
    back: 'A reactive pattern where consumers signal producers to slow down when they cannot keep up. Prevents queue overflow and memory exhaustion. Alternative to dropping requests.',
    category: 'distributed',
  },
  {
    id: 'cc-11',
    deck: 'core-concepts',
    front: 'What is database sharding?',
    back: 'Partitioning data across multiple database instances. Each shard contains a subset of the data. Enables horizontal scaling beyond single server limits. Challenges: cross-shard queries, rebalancing.',
    category: 'storage',
  },
  {
    id: 'cc-12',
    deck: 'core-concepts',
    front: 'OLTP vs. OLAP databases?',
    back: 'OLTP (Online Transaction Processing): Row-store, optimized for many small transactions, low latency (Postgres, MySQL). OLAP (Online Analytical Processing): Column-store, optimized for complex analytics, high throughput (Snowflake, BigQuery).',
    category: 'storage',
  },
  {
    id: 'cc-13',
    deck: 'core-concepts',
    front: 'What is a cache stampede?',
    back: 'When a popular cache entry expires and many requests simultaneously miss the cache, all querying the database at once. Solutions: stale-while-revalidate, distributed lock, probabilistic early expiration.',
    category: 'storage',
  },
  {
    id: 'cc-14',
    deck: 'core-concepts',
    front: 'Explain normalization vs. denormalization',
    back: 'Normalization: Eliminate redundancy, avoid update anomalies, enforce integrity (good for OLTP). Denormalization: Copy data for faster reads, no joins needed (good for OLAP/caches). Trade-off: integrity vs. performance.',
    category: 'storage',
  },
  {
    id: 'cc-15',
    deck: 'core-concepts',
    front: 'What is an SLA, SLO, and SLI?',
    back: 'SLI (Indicator): Measurable metric (e.g., latency). SLO (Objective): Target value for SLI (e.g., 99.9% uptime). SLA (Agreement): Contract with penalties if SLO violated. Error budget = (100% - SLO).',
    category: 'reliability',
  },
  {
    id: 'cc-16',
    deck: 'core-concepts',
    front: 'What is exponential backoff with jitter?',
    back: 'Retry strategy: delay = base * (2^attempt) + random. Exponential backoff increases wait time. Jitter adds randomness to prevent thundering herd (synchronized retries). Essential for resilient distributed systems.',
    category: 'reliability',
  },
  {
    id: 'cc-17',
    deck: 'core-concepts',
    front: 'What is RBAC?',
    back: 'Role-Based Access Control: Permissions assigned to roles, roles assigned to users. Users → Roles → Permissions. Simplifies permission management compared to direct user-permission assignment.',
    category: 'access-control',
  },
  {
    id: 'cc-18',
    deck: 'core-concepts',
    front: 'What is ABAC?',
    back: 'Attribute-Based Access Control: Access decisions based on attributes of user, resource, action, and environment. More flexible than RBAC but more complex. Example: "Allow if user.dept == resource.dept AND time < 5pm".',
    category: 'access-control',
  },
  {
    id: 'cc-19',
    deck: 'core-concepts',
    front: 'What is multi-tenancy?',
    back: 'Architecture where a single application instance serves multiple customers (tenants). Challenges: data isolation, performance isolation, customization. Patterns: shared schema, separate schemas, separate databases.',
    category: 'multi-tenant',
  },
  {
    id: 'cc-20',
    deck: 'core-concepts',
    front: 'What is the noisy neighbor problem?',
    back: 'When one tenant\'s resource usage degrades performance for other tenants in a multi-tenant system. Solutions: per-tenant quotas, rate limiting, fair scheduling, resource isolation.',
    category: 'multi-tenant',
  },

  // DESIGN PATTERNS DECK
  {
    id: 'dp-1',
    deck: 'design-patterns',
    front: 'Circuit Breaker Pattern',
    back: 'Automatically stop calling a failing service to allow it to recover. States: Closed (normal), Open (failing), Half-Open (testing). Prevents cascade failures and resource exhaustion.',
  },
  {
    id: 'dp-2',
    deck: 'design-patterns',
    front: 'Bulkhead Pattern',
    back: 'Isolate resources (thread pools, connections) to prevent cascade failures. If one dependency fails, it doesn\'t exhaust all resources. Like watertight compartments in a ship.',
  },
  {
    id: 'dp-3',
    deck: 'design-patterns',
    front: 'Saga Pattern',
    back: 'Manage distributed transactions across microservices using compensating transactions. Each step has a compensating action for rollback. Choreography (event-driven) or Orchestration (coordinator).',
  },
  {
    id: 'dp-4',
    deck: 'design-patterns',
    front: 'Transactional Outbox Pattern',
    back: 'Atomically update database and publish event by writing event to outbox table in same transaction. Background process publishes from outbox. Ensures consistency between DB and message queue.',
  },
  {
    id: 'dp-5',
    deck: 'design-patterns',
    front: 'Event Sourcing Pattern',
    back: 'Store state changes as sequence of events rather than current state. Events are immutable, append-only. Current state = replay all events. Benefits: complete audit trail, time travel, easy state rebuild.',
  },
  {
    id: 'dp-6',
    deck: 'design-patterns',
    front: 'CQRS (Command Query Responsibility Segregation)',
    back: 'Separate models for reading and writing data. Command model optimized for writes. Query model optimized for reads (often denormalized). Can use different databases for each.',
  },
  {
    id: 'dp-7',
    deck: 'design-patterns',
    front: 'Cache-Aside Pattern',
    back: 'Application checks cache first. On miss: fetch from database, store in cache, return. On write: update database, optionally invalidate cache. Only caches what\'s accessed.',
  },
  {
    id: 'dp-8',
    deck: 'design-patterns',
    front: 'Write-Through Cache Pattern',
    back: 'Writes go through cache to database synchronously. Cache always fresh. Trade-off: slower writes, may cache unused data.',
  },
  {
    id: 'dp-9',
    deck: 'design-patterns',
    front: 'Write-Behind (Write-Back) Cache Pattern',
    back: 'Writes update cache immediately, asynchronously flushed to database. Fast writes. Risks: data loss if cache fails, eventual consistency.',
  },
  {
    id: 'dp-10',
    deck: 'design-patterns',
    front: 'Leader Election Pattern',
    back: 'Process of designating one node as coordinator in distributed system. Use: Zookeeper, etcd, or Redis. Leader performs singleton tasks, followers standby. Lease-based with heartbeat.',
  },
  {
    id: 'dp-11',
    deck: 'design-patterns',
    front: 'Retry with Exponential Backoff',
    back: 'Retry failed operations with increasing delays (1s, 2s, 4s, 8s). Add jitter to prevent thundering herd. Set max retries and backoff cap. Don\'t retry client errors (4xx).',
  },
  {
    id: 'dp-12',
    deck: 'design-patterns',
    front: 'Strangler Fig Pattern',
    back: 'Gradually replace legacy system by incrementally routing traffic to new system. Old and new coexist. Eventually "strangle" old system. Enables zero-downtime migration.',
  },
  {
    id: 'dp-13',
    deck: 'design-patterns',
    front: 'API Gateway Pattern',
    back: 'Single entry point for clients to access microservices. Handles: routing, authentication, rate limiting, request aggregation. Decouples clients from service topology.',
  },
  {
    id: 'dp-14',
    deck: 'design-patterns',
    front: 'Database per Service Pattern',
    back: 'Each microservice has its own database. Pros: loose coupling, independent scaling. Cons: distributed transactions, data duplication. Use Saga or event sourcing for cross-service consistency.',
  },
  {
    id: 'dp-15',
    deck: 'design-patterns',
    front: 'Sidecar Pattern',
    back: 'Deploy helper component alongside main application. Handles cross-cutting concerns: logging, monitoring, proxying. Example: Envoy proxy in service mesh. Decouples infrastructure from business logic.',
  },

  // QUICK DEFINITIONS DECK
  {
    id: 'qd-1',
    deck: 'quick-definitions',
    front: 'What is a webhook?',
    back: 'HTTP callback triggered by an event. Server sends POST request to configured URL when event occurs. Used for real-time notifications instead of polling.',
  },
  {
    id: 'qd-2',
    deck: 'quick-definitions',
    front: 'What is a message queue?',
    back: 'Asynchronous communication pattern where producers send messages to queue and consumers process them. Examples: SQS, RabbitMQ, Kafka. Decouples services.',
  },
  {
    id: 'qd-3',
    deck: 'quick-definitions',
    front: 'What is horizontal vs. vertical scaling?',
    back: 'Horizontal: add more machines (scale out). Vertical: make machine bigger (scale up). Horizontal better for availability and limitless scaling. Vertical simpler but has ceiling.',
  },
  {
    id: 'qd-4',
    deck: 'quick-definitions',
    front: 'What is a load balancer?',
    back: 'Distributes incoming traffic across multiple servers. Algorithms: round-robin, least connections, IP hash. Enables horizontal scaling and high availability.',
  },
  {
    id: 'qd-5',
    deck: 'quick-definitions',
    front: 'What is a reverse proxy?',
    back: 'Server that sits in front of web servers and forwards requests. Handles: SSL termination, caching, compression, load balancing. Examples: nginx, HAProxy, Cloudflare.',
  },
  {
    id: 'qd-6',
    deck: 'quick-definitions',
    front: 'What is CDN (Content Delivery Network)?',
    back: 'Distributed network of servers that cache content close to users. Reduces latency and origin server load. Examples: CloudFront, Cloudflare, Akamai.',
  },
  {
    id: 'qd-7',
    deck: 'quick-definitions',
    front: 'What is a microservice?',
    back: 'Architectural style where application is a collection of small, independent services. Each service: single business capability, independently deployable, own database.',
  },
  {
    id: 'qd-8',
    deck: 'quick-definitions',
    front: 'What is service mesh?',
    back: 'Infrastructure layer handling service-to-service communication. Provides: service discovery, load balancing, encryption, observability. Examples: Istio, Linkerd.',
  },
  {
    id: 'qd-9',
    deck: 'quick-definitions',
    front: 'What is a monolith?',
    back: 'Application where all components are part of single codebase and deployed together. Simpler to develop and deploy initially, harder to scale and maintain at large scale.',
  },
  {
    id: 'qd-10',
    deck: 'quick-definitions',
    front: 'What is database replication?',
    back: 'Copying data from primary database to one or more replica databases. Read replicas handle read queries, reducing primary load. Enables high availability and disaster recovery.',
  },
  {
    id: 'qd-11',
    deck: 'quick-definitions',
    front: 'What is consensus?',
    back: 'Distributed systems agreeing on a value despite failures. Algorithms: Paxos, Raft. Used for: leader election, distributed locks, configuration management. Examples: Zookeeper, etcd.',
  },
  {
    id: 'qd-12',
    deck: 'quick-definitions',
    front: 'What is an idempotency key?',
    back: 'Unique identifier sent with request to deduplicate operations. Server stores key with result. On retry, returns cached result if key exists. Prevents duplicate charges, orders, etc.',
  },
  {
    id: 'qd-13',
    deck: 'quick-definitions',
    front: 'What is rate limiting?',
    back: 'Restricting number of requests in time window. Protects against: abuse, overload, DDoS. Algorithms: token bucket, leaky bucket, sliding window. Returns 429 (Too Many Requests).',
  },
  {
    id: 'qd-14',
    deck: 'quick-definitions',
    front: 'What is graceful degradation?',
    back: 'System continues operating with reduced functionality when components fail. Example: show cached recommendations if recommendation engine down. Better than complete failure.',
  },
  {
    id: 'qd-15',
    deck: 'quick-definitions',
    front: 'What is a hot path vs. cold path?',
    back: 'Hot path: frequently executed, performance-critical code. Cold path: rarely executed (error handling, admin features). Optimize hot path, simplify cold path.',
  },
  {
    id: 'qd-16',
    deck: 'quick-definitions',
    front: 'What is connection pooling?',
    back: 'Reusing database connections instead of creating new ones per request. Reduces handshake overhead. Configure pool size based on concurrent query needs.',
  },
  {
    id: 'qd-17',
    deck: 'quick-definitions',
    front: 'What is a primary key?',
    back: 'Unique identifier for database row. Enforces uniqueness, used for indexing and joins. Natural (business value) or surrogate (generated ID). Immutable.',
  },
  {
    id: 'qd-18',
    deck: 'quick-definitions',
    front: 'What is a foreign key?',
    back: 'Column referencing primary key in another table. Enforces referential integrity. Enables joins. Can have constraints (cascade delete, restrict).',
  },
  {
    id: 'qd-19',
    deck: 'quick-definitions',
    front: 'What is optimistic locking?',
    back: 'Assume no conflicts, check at commit time. Use version number or timestamp. If version changed, conflict detected, retry. Good for low-conflict scenarios.',
  },
  {
    id: 'qd-20',
    deck: 'quick-definitions',
    front: 'What is pessimistic locking?',
    back: 'Acquire lock before reading. Prevents concurrent modifications. Hold lock until transaction complete. Good for high-conflict scenarios. Risks: deadlocks.',
  },
  {
    id: 'qd-21',
    deck: 'quick-definitions',
    front: 'What is database partitioning?',
    back: 'Splitting table into segments. Horizontal: by rows (by date, ID range). Vertical: by columns. Improves query performance and enables parallel processing.',
  },
  {
    id: 'qd-22',
    deck: 'quick-definitions',
    front: 'What is an API?',
    back: 'Application Programming Interface: contract for how software components interact. Defines: endpoints, request/response formats, authentication. REST, GraphQL, gRPC.',
  },
  {
    id: 'qd-23',
    deck: 'quick-definitions',
    front: 'What is REST?',
    back: 'Representational State Transfer: architectural style for APIs. Uses HTTP methods (GET, POST, PUT, DELETE), stateless, resource-based URLs, JSON/XML responses.',
  },
  {
    id: 'qd-24',
    deck: 'quick-definitions',
    front: 'What is GraphQL?',
    back: 'Query language for APIs. Client specifies exactly what data needed. Single endpoint, avoids over/under-fetching. Trade-offs: complexity, caching harder than REST.',
  },
  {
    id: 'qd-25',
    deck: 'quick-definitions',
    front: 'What is gRPC?',
    back: 'High-performance RPC framework using Protocol Buffers. Binary protocol, strongly typed, supports streaming. Faster than REST but less human-readable. Good for service-to-service.',
  },
  {
    id: 'qd-26',
    deck: 'quick-definitions',
    front: 'What is Kafka?',
    back: 'Distributed event streaming platform. Publish/subscribe model with topics and partitions. High throughput, durable, ordered within partition. Use for: event sourcing, data pipelines.',
  },
  {
    id: 'qd-27',
    deck: 'quick-definitions',
    front: 'What is Redis?',
    back: 'In-memory data store. Use cases: cache, session store, pub/sub, leaderboards, rate limiting. Data structures: strings, hashes, lists, sets, sorted sets. Ephemeral or persistent.',
  },
  {
    id: 'qd-28',
    deck: 'quick-definitions',
    front: 'What is Zanzibar?',
    back: 'Google\'s authorization system based on relationship tuples. Model: (object, relation, subject). Operations: Check (has permission?), Expand (who has access?). Powers Google Drive, Docs.',
  },
  {
    id: 'qd-29',
    deck: 'quick-definitions',
    front: 'What is Lambda architecture?',
    back: 'Hybrid data processing: batch layer (complete, accurate), speed layer (fast, approximate), serving layer (merge both). Handles late data. Complexity: two codebases.',
  },
  {
    id: 'qd-30',
    deck: 'quick-definitions',
    front: 'What is Kappa architecture?',
    back: 'Everything is a stream. Single processing engine for real-time and historical (replay stream). Simpler than Lambda but requires careful stream retention.',
  },
  {
    id: 'qd-31',
    deck: 'quick-definitions',
    front: 'What is eventual consistency?',
    back: 'System becomes consistent over time, not immediately. Allows temporary inconsistency for availability/performance. Example: DNS propagation, replica lag.',
  },
  {
    id: 'qd-32',
    deck: 'quick-definitions',
    front: 'What is strong consistency?',
    back: 'All clients see same data at same time. Every read returns most recent write. Requires coordination, reduces availability. Example: traditional RDBMS transactions.',
  },
  {
    id: 'qd-33',
    deck: 'quick-definitions',
    front: 'What is BASE (vs ACID)?',
    back: 'Basically Available, Soft state, Eventual consistency. NoSQL alternative to ACID. Trade consistency for availability and partition tolerance. Example: DynamoDB, Cassandra.',
  },
  {
    id: 'qd-34',
    deck: 'quick-definitions',
    front: 'What is two-phase commit (2PC)?',
    back: 'Distributed transaction protocol. Phase 1: prepare (vote). Phase 2: commit (if all yes) or abort. Coordinator ensures atomicity. Blocks on coordinator failure.',
  },
  {
    id: 'qd-35',
    deck: 'quick-definitions',
    front: 'What is a distributed lock?',
    back: 'Mutex across multiple processes/servers. Ensures only one process executes critical section. Implementations: Redis (Redlock), Zookeeper, etcd. Must have expiry to prevent deadlocks.',
  },
  {
    id: 'qd-36',
    deck: 'quick-definitions',
    front: 'What is a fencing token?',
    back: 'Monotonically increasing number included with lock. Prevents stale lock holder from corrupting state after lock expired. Resource checks token and rejects lower values.',
  },
  {
    id: 'qd-37',
    deck: 'quick-definitions',
    front: 'What is a circuit breaker?',
    back: 'Stop calling failing service to allow recovery. States: Closed (normal), Open (failing, reject immediately), Half-Open (test recovery). Prevents cascade failures.',
  },
  {
    id: 'qd-38',
    deck: 'quick-definitions',
    front: 'What is a health check?',
    back: 'Endpoint exposing service health (/health, /healthz). Returns 200 if healthy. Load balancers remove unhealthy instances. Types: liveness (is it running?), readiness (can it serve traffic?).',
  },
  {
    id: 'qd-39',
    deck: 'quick-definitions',
    front: 'What is chaos engineering?',
    back: 'Deliberately injecting failures to test system resilience. Example: Netflix Chaos Monkey randomly terminates instances. Validates: failover, circuit breakers, retries work.',
  },
  {
    id: 'qd-40',
    deck: 'quick-definitions',
    front: 'What is blue-green deployment?',
    back: 'Two identical environments (blue=current, green=new). Deploy to green, test, switch traffic. Easy rollback (switch back to blue). Trade-off: double infrastructure cost.',
  },

  // TRADE-OFFS DECK
  {
    id: 'to-1',
    deck: 'trade-offs',
    front: 'When would you choose SQL over NoSQL?',
    back: 'Choose SQL when: complex relationships (joins), ACID transactions required, structured data with known schema, strong consistency needed. Example: financial transactions, inventory management.',
  },
  {
    id: 'to-2',
    deck: 'trade-offs',
    front: 'When would you choose NoSQL over SQL?',
    back: 'Choose NoSQL when: massive scale, flexible schema, simple access patterns, high write throughput, eventual consistency acceptable. Example: user sessions, IoT data, product catalog.',
  },
  {
    id: 'to-3',
    deck: 'trade-offs',
    front: 'When would you choose push over pull architecture?',
    back: 'Choose push (webhooks, websockets) when: real-time updates critical, low latency required, server knows when to send. Example: chat, notifications. Trade-off: client must be online, webhook reliability.',
  },
  {
    id: 'to-4',
    deck: 'trade-offs',
    front: 'When would you choose pull over push architecture?',
    back: 'Choose pull (polling, API requests) when: client controls timing, intermittent connectivity, simpler to implement. Example: mobile apps checking for updates. Trade-off: higher latency, wasted polls.',
  },
  {
    id: 'to-5',
    deck: 'trade-offs',
    front: 'When would you choose synchronous over asynchronous processing?',
    back: 'Choose sync when: immediate response needed, simple request-reply, low latency critical, short operations (<100ms). Example: user login, reading data, balance check.',
  },
  {
    id: 'to-6',
    deck: 'trade-offs',
    front: 'When would you choose asynchronous over synchronous processing?',
    back: 'Choose async when: long-running operations, high throughput needed, decoupling services, operation can fail and retry. Example: email sending, report generation, data processing.',
  },
  {
    id: 'to-7',
    deck: 'trade-offs',
    front: 'When would you choose strong consistency over eventual consistency?',
    back: 'Choose strong consistency when: correctness critical (financial transactions), users expect immediate consistency (write then read own data), audit/compliance requirements. Trade-off: lower availability, higher latency.',
  },
  {
    id: 'to-8',
    deck: 'trade-offs',
    front: 'When would you choose eventual consistency over strong consistency?',
    back: 'Choose eventual consistency when: availability > consistency, high scale needed, users tolerate staleness (feed, recommendations). Trade-off: complex conflict resolution, confusing UX if done wrong.',
  },
  {
    id: 'to-9',
    deck: 'trade-offs',
    front: 'When would you choose batch processing over stream processing?',
    back: 'Choose batch when: latency tolerance (hours/days), cost efficiency critical, complete dataset needed before processing, simpler to implement. Example: nightly reports, monthly billing.',
  },
  {
    id: 'to-10',
    deck: 'trade-offs',
    front: 'When would you choose stream processing over batch processing?',
    back: 'Choose stream when: real-time insights needed, continuous processing, event-driven architecture, low latency critical. Example: fraud detection, monitoring, real-time analytics. Trade-off: complexity, cost.',
  },
  {
    id: 'to-11',
    deck: 'trade-offs',
    front: 'When would you choose microservices over monolith?',
    back: 'Choose microservices when: large team, need independent deployments, different scaling requirements per service, polyglot needs. Trade-off: operational complexity, distributed systems challenges.',
  },
  {
    id: 'to-12',
    deck: 'trade-offs',
    front: 'When would you choose monolith over microservices?',
    back: 'Choose monolith when: small team, simple domain, starting new product, want to move fast. Easier to develop, deploy, debug, test. Can extract microservices later when needed.',
  },
  {
    id: 'to-13',
    deck: 'trade-offs',
    front: 'When would you choose normalized over denormalized data?',
    back: 'Choose normalized when: write-heavy workload, data integrity critical, storage expensive, reducing redundancy important. Example: OLTP systems, transactional data.',
  },
  {
    id: 'to-14',
    deck: 'trade-offs',
    front: 'When would you choose denormalized over normalized data?',
    back: 'Choose denormalized when: read-heavy workload, query performance critical, joins too expensive. Example: OLAP systems, caches, reporting databases. Trade-off: update complexity, redundancy.',
  },
  {
    id: 'to-15',
    deck: 'trade-offs',
    front: 'When would you choose REST over GraphQL?',
    back: 'Choose REST when: simple CRUD, caching important, public API (wider tool support), resource-based model fits. Simpler, more cacheable, wider adoption.',
  },
  {
    id: 'to-16',
    deck: 'trade-offs',
    front: 'When would you choose GraphQL over REST?',
    back: 'Choose GraphQL when: complex nested data, clients need flexibility, avoiding over/under-fetching, multiple client types. Trade-off: complexity, caching harder, security (query depth limits needed).',
  },
  {
    id: 'to-17',
    deck: 'trade-offs',
    front: 'When would you choose shared database per tenant over separate databases?',
    back: 'Choose shared database when: many small tenants, cost efficiency critical, easier operations, tenant size similar. Example: B2C SaaS with thousands of small customers.',
  },
  {
    id: 'to-18',
    deck: 'trade-offs',
    front: 'When would you choose separate databases per tenant over shared?',
    back: 'Choose separate when: enterprise customers, data residency requirements, strong isolation needed, tenants vary greatly in size. Trade-off: higher cost, operational complexity.',
  },
  {
    id: 'to-19',
    deck: 'trade-offs',
    front: 'When would you choose RBAC over ABAC?',
    back: 'Choose RBAC when: simple permission model, clear role structure, performance critical (simple lookups). Easier to understand and implement. Example: small SaaS with Admin/Editor/Viewer roles.',
  },
  {
    id: 'to-20',
    deck: 'trade-offs',
    front: 'When would you choose ABAC over RBAC?',
    back: 'Choose ABAC when: complex business rules, context-aware permissions (time, location, ownership), roles insufficient. Example: "managers can approve expenses under $1000 in their department".',
  },
]
